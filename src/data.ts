import props from "./props.json"
import alts from "./alternates.json"


export const loadData = () => {
      // This map is used to store market data indexed by a key generated by buildEntryKey.
      // We need the map just for the initial processing to optimize lookup times for updating data in alternates.
      const entries: Map<string, MarketData> = new Map()

      const buildEntryKey = (playerId: number, statTypeId: number) => {
            return `${playerId}-${statTypeId}`
      }
      for (const entry of props) {
            const key = buildEntryKey(entry.playerId, entry.statTypeId)
            const marketDataEntry: MarketData = {
                  playerName: entry.playerName,
                  playerId: entry.playerId,
                  teamId: entry.teamId,
                  teamNickname: entry.teamNickname,
                  teamAbbr: entry.teamAbbr,
                  statType: entry.statType,
                  statTypeId: entry.statTypeId,
                  position: entry.position,
                  marketSuspended: entry.marketSuspended === 1,
                  line: entry.line,
                  // Set it to what we know, we will update these when we read alternates.
                  lowLine: entry.line,
                  highLine: entry.line,
                  optimalLineFoundInAlternates: false
            }

            entries.set(key, marketDataEntry)
      }


      for (const entry of alts) {
            const key = buildEntryKey(entry.playerId, entry.statTypeId)
            // Since market data entry is an object we can directly modify it without needing to update the map.
            const marketDataEntry = entries.get(key)
            if (marketDataEntry !== undefined) {
                  // Now we just compare the existing entry
                  // with alt entry to update highs and lows.
                  if (marketDataEntry.lowLine > entry.line) {
                        marketDataEntry.lowLine = entry.line
                  }

                  if (marketDataEntry.highLine < entry.line) {
                        marketDataEntry.highLine = entry.line
                  }

                  // Market Suspended calculations - only apply to optimal line.
                  if (!marketDataEntry.marketSuspended && entry.line === marketDataEntry.line) {
                        // Mark if we found the optimal line from props in alts.
                        // We will use this later to suspend the market if we don't find it.
                        marketDataEntry.optimalLineFoundInAlternates = true
                        // Now we need to check the probabilities.
                        // If the probability is less than 0.4 for all three, we suspend the market.
                        if (entry.overOdds < 0.4 &&
                              entry.underOdds < 0.4 &&
                              entry.pushOdds < 0.4
                        ) {
                              marketDataEntry.marketSuspended = true
                        }
                  }
            }
      }

      const marketData: MarketData[] = []
      // Now we need to check if we found the optimal line in alternates.
      // If not, we suspend the market.
      for (const entry of entries.values()) {
            if (!entry.marketSuspended && !entry.optimalLineFoundInAlternates) {
                  entry.marketSuspended = true
            }

            marketData.push(entry)
      }

      return marketData
}



export interface MarketData {
      playerName: string;
      playerId: number;
      teamId: number;
      teamNickname: string;
      teamAbbr: string;
      statType: string;
      statTypeId: number;
      position: string;
      marketSuspended: boolean;
      line: number;
      lowLine: number;
      highLine: number;
      manualSuspension?: boolean; // to track manual suspensions/releases
      optimalLineFoundInAlternates: boolean;
      [key: string]: string | number | boolean | undefined;  // This is to make the MarketData interface indexable.
}
